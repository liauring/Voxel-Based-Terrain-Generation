<!DOCTYPE html>
< lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voxel Based Terrain Generation</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            padding: 20px;
            background-color: #f5f6f8;
            color: #333;
        }

        h2, h3, h4, h5, h6 {
            margin-top: 1.2em;
            margin-bottom: 0.5em;
        }
        h1 {
            font-size: 2em;
            font-weight: bold;
            margin-top: 0.5em;
            margin-bottom: 0.5em;
        }
        h2 {
            font-size: 1.75em;
            font-weight: bold;
        }
        h3 {
            font-size: 1.5em;
            font-weight: bold;
        }
        h4 {
            font-size: 1.25em;
            font-weight: bold;
        }
        h5 {
            font-size: 1.1em;
            font-weight: bold;
        }
        h6 {
            font-size: 1em;
            font-weight: bold;
        }
        p {
            margin: 0.5em 0;
        }
        ul, ol {
            margin: 0.5em 0;
            padding-left: 20px;
        }
        blockquote {
            margin: 1em 0;
            padding: 10px;
            background-color: #e8ebed;
            border-left: 4px solid #c2c5c8;
            font-style: italic;
            color: #555;
        }

        pre {
            background-color: #f5f5f5; 
            color: #333333;
            padding: 16px;
            border-radius: 8px;
            overflow-x: auto; 
            font-family: 'Courier New', Courier, monospace;
            font-size: 14px; 
            line-height: 1.5;
            border: 1px solid #ddd;
        }

        
        code {
            color: #333333;
        }

        code .keyword {
            color: #d73a49;
            font-weight: bold;
        }

        code .type {
            color: #005cc5;
        }

        code .function {
            color: #6f42c1;
        }

        code .comment {
            color: #6a737d;
            font-style: italic;
        }

        code .number {
            color: #005cc5;
        }

        code .string {
            color: #032f62;
        }

        hr {
            border: 0;
            height: 1px;
            background-color: #ccc;
            margin: 2em 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            font-size: 16px;
            font-family: Arial, sans-serif;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        table thead th {
            background-color: #7b7b7b;
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: bold;
            border: 1px solid #ddd;
        }

        table tbody td {
            background-color: #f9f9f9;
            padding: 12px;
            border: 1px solid #ddd;
            text-align: left;
        }

        table tbody tr:nth-child(even) td {
            background-color: #f1f1f1;
        }

        table tbody tr:hover td {
            background-color: #eaf3e3;
            color: #333;
        }

        body {
            width: 70%;
            max-width: 100%;
            min-width: 500px;
            margin: 30px auto;
            padding: 20px;
            font-family: Arial, sans-serif;
            line-height: 1.6;
            background-color: #f5f6f8;
            color: #333;
    }
    </style>
</head>
<br>

    <h1>Voxel Based Terrain Generation</h1>

    <h2>SUMMARY</h2>
    <p>We will focus on developing optimized implementations of voxel-based terrain rendering primarily using <u>Perspective Projection</u>, optimized for both GPU and multi-core CPU platforms. There is potential to further enhance performance by delving into advanced ray-tracing techniques, leveraging algorithms such as Fast Voxel Traversal and 64-Tree for deeper optimizations.</p>

    <h2>BACKGROUND</h2>
    <p>Our project focuses on accelerating voxel-based terrain rendering, specifically targeting performance improvements on GPU and multi-core CPU platforms. Voxel-based terrain rendering is a compute-intensive process that involves creating detailed, three-dimensional landscapes by representing space as a grid of voxels, where each voxel holds information about height, color, and material properties.</p>
    <p>The pseudocode uses a <u>Perspective Projection</u> to render a 3D terrain from a height map.</p>
    <pre>
<code>
    <span class="keyword">void</span> <span class="function">renderTerrain</span>(<span class="keyword">const</span> <span class="type">HeightMap&amp;</span> heightMap, <span class="keyword">int</span> screenWidth, <span class="keyword">int</span> screenHeight, <span class="keyword">int</span> horizon, <span class="keyword">float</span> scale) {
        <span class="comment">// Loop over each column (x-coordinate) on the screen</span>
        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; screenWidth; ++x) {
            <span class="comment">// Loop from the back of the terrain (far z) to the front (near z)</span>
            <span class="keyword">for</span> (<span class="keyword">int</span> z = heightMap.getHeight(<span class="number">0</span>, <span class="number">0</span>); z &lt; screenWidth; ++z) {
                ...
                drawVerticalLine(x, projectedY, maxY, color);
            }
        }
    }

    <span class="keyword">void</span> <span class="function">drawVerticalLine</span>(<span class="keyword">int</span> x, <span class="keyword">float</span> yStart, <span class="keyword">float</span> yEnd, <span class="keyword">const</span> <span class="type">Color&amp;</span> color) {
        <span class="comment">// Draw a vertical line from yStart to yEnd at x with the given color</span>
        <span class="comment">// In a real implementation, you would draw pixels on a display or window</span>
    }
</code>
</pre>
    <p>Here’s how parallelism can be applied and the performance benefits it offers:</p>
    <ul>
        <li>
            <strong>Column-Based Parallelism: </strong> <code>void renderTerrain()</code>
            <ul>
                <li>Each vertical column on the screen corresponds to a segment of the terrain that can be computed independently. This independence allows for parallel rendering, where each column or a block of columns can be assigned to a separate thread.</li>
                <li>This approach is well-suited to multi-core CPUs, as each core can process different sections of the screen simultaneously, reducing rendering time significantly.</li>
            </ul>
        </li>

        <li>
            <strong>Efficient Use of GPU Cores: </strong> <code>void drawVerticalLine()</code>
            <ul>
                <li>On GPU platforms, each pixel or line can be handled by a separate GPU core. By leveraging thousands of GPU cores, the algorithm can render all screen columns in parallel, providing real-time terrain visualization even for large-scale maps.</li>
                <li>The GPU’s parallel structure can accelerate computations such as perspective projection and color mapping across all screen columns, making the algorithm ideal for terrain rendering tasks that require quick updates or real-time interactivity.</li>
            </ul>
        </li>

        <li>
            <strong>Load Balancing for Large Scenes</strong>
            <ul>
                <li>By distributing columns evenly across processing units (CPU cores or GPU threads), the workload is balanced, and the algorithm achieves consistent rendering performance. For example, screen columns at varying depths might require slightly different amounts of computation (e.g., handling distant occlusions), but parallelism mitigates bottlenecks.</li>
            </ul>
        </li>
    </ul>
    

    <h2>THE CHALLENGE</h2>
    <p>The Basic Terrain Rendering Algorithm, based on a height map and color map, is challenging primarily due to the need for real-time rendering while ensuring smooth perspective projection and occlusion handling. The workload involves projecting terrain heights to a 2D screen, which needs to be efficient enough to avoid lag, especially for large-scale maps or high-resolution outputs.</p>
    <h3>Workload</h3>
    <ul>
        <li><strong>Dependencies:</strong> Each screen column (vertical line) can be processed independently, which reduces dependencies between columns. However, there’s a dependency on the horizon line and the perspective projection parameters, which control how height data translates to screen space.</li>
        
        <li><strong>Memory Access:</strong> This algorithm accesses the height map data for each terrain segment, leading to sequential memory access if columns are processed from left to right. There is some locality in memory access since nearby columns are likely to reference similar data.</li>
        
        <li><strong>Communication to Computation Ratio:</strong> The communication overhead is low as each column calculation is largely independent. The main computation is the height-to-screen projection and occlusion check, which doesn’t require frequent inter-thread communication.</li>
        
        <li><strong>Divergent Execution:</strong> Divergence is minimal in this algorithm. Each column undergoes similar height and perspective calculations, though columns closer to the horizon may involve additional checks for occlusion.</li>
    </ul>
    <h3>Constraints</h3>
    <ul>
        <li><strong>System Constraints:</strong> Mapping this workload to a parallel system involves handling large arrays of height data, which may not fit entirely into cache on the CPU or GPU. Efficient caching and minimizing memory latency are crucial. On a multi-core CPU, balancing the workload per core may be necessary due to varying computational demands (e.g., columns closer to the horizon require more occlusion checks).</li>
        
        <li><strong>Graphics Constraints:</strong> On GPU, each thread could render a column or a portion of it, but managing memory for consistent, real-time rendering is essential. Synchronizing outputs and maintaining a smooth frame rate is necessary for optimal performance.</li>
    </ul>
    
    <h2>RESOURCES</h2>
    <p>The project will be built from scratch in C++, with no specific starter code. We are going to looking for existing height maps and color maps available from online repositories or open-source datasets to simulate terrain features. </p>
    <p>Additionally, we will explore C++ libraries to handle graphic rendering, possibly OpenGL, SDL, or SFML, to facilitate rendering the height map and visualizing results on the screen. It  may require additional time to learn how to integrate these with the terrain rendering algorithm. Access to a graphical visualization library will help ensure that the rendered terrain can be displayed efficiently.</p>

    <h2>GOALS AND DELIVERABLES</h2>
    <ul>
        <li>
            <strong>Separate your goals into what you PLAN TO ACHIEVE (what you believe you must get done to have a successful project and get the grade you expect) and an extra goal or two that you HOPE TO ACHIEVE if the project goes really well and you get ahead of schedule, as well as goals in case the work goes more slowly. It may not be possible to state precise performance goals at this time, but we encourage you be as precise as possible. If you do state a goal, give some justification of why you think you can achieve it. (e.g., I hope to speed up my starter code 10x, because if I did it would run in real-time.)</strong>
            <ul>
                <li>
                    <strong>Plan to Achieve: Voxel Rendering on parallel CPU and GPU</strong>
                    <ul class="sub-list">
                        <li>
                            <strong>Develop Serial (Single-Threaded) Implementation:</strong>
                            <ul>
                                <li>Implement a serial version of the algorithm as a baseline.</li>
                                <li>Finalize performance metrics to evaluate future optimizations.
                                    <ul>
                                        <li>Processing time</li>
                                        <li>Data transfer time</li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>
                            <strong>Implement CPU Parallel Version:</strong>
                            <ul>
                                <li>Develop a parallel version optimized for multi-core CPUs.</li>
                                <li>Measure its performance against the serial version.</li>
                                <li>Optimize further by reducing synchronizations and leveraging AVX for hardware acceleration.</li>
                            </ul>
                        </li>
                        <li>
                            <strong>Develop GPU Parallel Version:</strong>
                            <ul>
                                <li>Implement the algorithm on a GPU.</li>
                                <li>Measure performance compared with serial and CPU parallel versions.</li>
                                <li>Apply GPU-specific optimizations such as utilizing shared memory and optimizing thread blocks.</li>
                            </ul>
                        </li>
                        <li>
                            <strong>Analyze Data and Optimize Further:</strong>
                            <ul>
                                <li>Collect performance data for all versions.</li>
                                <li>Analyze results to identify additional areas for optimization.</li>
                                <li>Implement further enhancements to maximize efficiency.</li>
                            </ul>
                        </li>
                        <li>
                            <strong>Combine CPU and GPU for Hybrid Optimization:</strong>
                            <ul>
                                <li>Analyze performance metrics to identify CPU vs. GPU benefits.</li>
                                <li>Test a hybrid approach for further performance gains.</li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li>
                    <strong>Extra Goal: Advanced ray-tracing techniques</strong>
                    <p><u>Fast Voxel Traversal</u> is efficient in calculating which voxels a ray intersects as it moves through the terrain, allowing us to quickly identify surface voxels that interact with the ray. The 64-Tree structure, which organizes voxel data into a sparse hierarchical structure, will enable us to skip empty or redundant regions of the voxel grid, focusing computational resources on areas with detail. This combination of algorithms reduces the computational load by avoiding unnecessary calculations in empty space and quickly navigating complex areas with minimal memory overhead.</p>
            <p>Ray-tracing over voxel terrains is inherently parallelizable, as each ray operates independently in tracing its path through the voxel grid. On GPU platforms, thousands of rays can be cast simultaneously, with each thread on the GPU independently traversing its own set of voxels. This parallel approach is well-suited for GPUs, where we can maximize throughput by assigning each ray its own processing unit. On multi-core CPUs, we will parallelize at the core level, dividing sections of the terrain across cores to process simultaneously, enabling efficient multi-threading for complex terrain calculations.</p>
        
            <p>The pseudocode uses <u>Fast Voxel Traversal</u> for the ray-tracing algorithm.</p>
            <pre>
<code>
    <span class="type">Color</span> <span class="function">rayTrace</span>(<span class="keyword">const</span> <span class="type">VoxelGrid&amp;</span> voxel_grid, <span class="type">Ray&amp;</span> ray, <span class="keyword">int</span> max_depth) {
        <span class="comment">// Return the color</span>
    }

    <span class="keyword">void</span> <span class="function">renderTerrain</span>(<span class="keyword">const</span> <span class="type">VoxelGrid&amp;</span> voxel_grid, <span class="type">std::vector&amp;</span> rays, <span class="keyword">int</span> max_depth) {
        <span class="comment">// Parallelize loop across multiple CPU threads</span>
        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; rays.size(); ++i) {
            rays[i].accumulated_color = <span class="function">rayTrace</span>(voxel_grid, rays[i], max_depth);
        }
    }
</code>
            </pre>
        
                </li>
            </ul>
        </li>
        <li>
            <strong>If applicable, describe the demo you plan to show at the poster session (Will it be an interactive demo? Will you show an output of the program that is really neat? Will you show speedup graphs?). Specifically, what will you show us that will demonstrate you did a good job?</strong>
            <p>For the poster session, the demo will include both a visual showcase of the rendered terrain and performance analysis results to highlight the effectiveness of the implemented algorithm.</p>
            <ul>
                <li>Visual Showcase</li>
                <ul>
                    <li>The demo will display a rendered terrain based on height maps, using perspective projection for a 3D effect.</li>
                    <li>Side-by-side comparison of simple (e.g., flat) and complex (e.g., mountainous) terrains will demonstrate the algorithm’s robustness.</li>
                </ul>
                <li>Performance Metrics</li>
                <ul>
                    <li><strong>Speedup Graphs:</strong> Graphs showing the performance improvements when parallelizing the algorithm (e.g., sequential vs. multi-core CPU, or GPU acceleration if implemented).</li>
                    <li><strong>Resource Utilization:</strong> Analysis of memory usage and processing time for different terrain complexities and resolutions.</li>
                    <li><strong>Advanced Ray-Tracing Features Speedup Graph</strong> (if implemented): Showcase improved shading, occlusion handling, or visual realism.</li>
                </ul>
            </ul>
        </li>
        <li>
            <strong>If your project is an analysis project, what are you hoping to learn about the workload or system being studied? What question(s) do you plan to answer in your analysis?</strong>
            <ul>
                <li><strong>Parallelization Impact:</strong>
                    <ul class="sub-list">
                        <li>How does the workload distributed across cores in a multi-core CPU and GPU differ?
                            <ul>
                                <li>CPU offers opportunities for both SIMD and MIMD optimizations. SIMD can be implemented through ISPC instructions to take advantage of the AVX hardware, while MIMD can be achieved through launching different threads on different cores.</li>
                                <li>GPU offers much easier implementation on SIMD and it also provides much more SIMD cores than CPU.</li>
                                <li>As a result, general computations, like data processing or control flow operations, can be efficiently handled by the CPU, while repetitive, parallelizable tasks, such as voxel rendering, are best offloaded to the GPU.</li>
                            </ul>
                        </li>
                        <li>When comparing CPU and GPU, what are the differences in bottlenecks in memory or computation?
                            <ul>
                                <li>CPUs are often limited by memory bandwidth and latency, whereas GPUs are more constrained by their computational throughput and efficiency in parallel processing.</li>
                                <li>GPUs can face significant bottlenecks due to the latency of data transfer between the CPU and GPU, as well as the overhead associated with kernel launches.</li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li><strong>Scalability:</strong>
                    <ul class="sub-list">
                        <li>How well does the algorithm scale with increased terrain resolution or complexity?
                            <ul>
                                <li>The algorithm should theoretically scale efficiently on the GPU as the resolution or map size increases, allowing more voxels to utilize the GPU cores simultaneously.</li>
                                <li>Main limitations would include data transmission between the CPU and GPU, as well as the finite number of Streaming Multiprocessors (SMs) available on the GPU, which can cap the parallel performance as the workload grows.</li>
                            </ul>
                        </li>
                        <li>What is the impact of increasing the number of threads or GPU cores on rendering time?
                            <ul>
                                <li>Having more GPU cores will shorten the rendering time. However, it will not be linear, since there will be an impact on data transmissions as well as scheduling overhead.</li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li><strong>Locality and Memory Efficiency:</strong>
                    <ul class="sub-list">
                        <li>How does the algorithm leverage spatial locality in height map access?
                            <ul>
                                <li>Ideally, voxels will be independent of each other and each voxel will read and process its local region.</li>
                                <li>Spatial locality may be beneficial through reading and reusing its local region.</li>
                            </ul>
                        </li>
                        <li>What optimizations (e.g., caching or memory layout changes) yield the most significant performance gains?
                            <ul>
                                <li>Optimizations could be experimented with by changing memory layouts, using shared memory, or manipulating the algorithm to benefit from memory locality.</li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li><strong>Key Questions to Answer:</strong>
                    <ul class="sub-list">
                        <li>What are the trade-offs between memory usage and computational efficiency in rendering high-resolution terrains?</li>
                        <li>How can bottlenecks in rendering be minimized to achieve real-time performance?</li>
                    </ul>
                </li>
            </ul>
        </li>
        <li>
            <strong>Systems project proposals should describe what the system will be capable of and what performance is hoped to be achieved.</strong>
            <ul>
                <li>System capabilities</li>
                <ul>
                    <li>
                        <strong>GPU:</strong> Optimized for executing <i>SIMD (Single Instruction, Multiple Data)</i> instructions, allowing efficient parallel processing for rendering voxel-based terrains.
                    </li>
                    <li>
                        <strong>CPU:</strong> Provides greater flexibility in workload distribution, capable of handling both <i>MIMD (Multiple Instruction, Multiple Data)</i> and <i>SIMD</i> instructions using technologies like <i>pthreads</i>, <i>OpenMP</i>, and <i>AVX hardware acceleration</i> to maximize multi-core performance.
                    </li>
                </ul>
                <li>Performance goal</li>
                <ul>
                    <li>The CPU goal for 8 core GHC  machine is 5x and for 64 core PHC core machine is 20x. The speedup is evaluated from the experiments done in assignment 3. Given the significant parallel computation potential of this project, we aim to achieve similar or potentially even greater speedup than observed in previous experiments.</li>
                    <li>While the specific speedup on the GPU will depend on evaluating communication costs and scheduling overhead, we expect a significant performance improvement compared to the CPU performance due to the GPU’s parallel processing capabilities. Additionally, we expect the GPU performance on the PSC system to be approximately 1.5x higher than on the GHC system when utilizing a single graphics card since V100 offers almost twice the amount of CUDA cores than RTX 2080. Besides, the higher memory bandwidth of V100 will also reduce the latency from data transfer. </li>
                </ul>
            
            </ul>
        </li>
    </ul>
    <h2>PLATFORM CHOICE</h2>
    <ul>
        <li>
            <strong>PSC Machine for CPU & GPU Performance Comparison</strong>
            <ul class="sub-list">
                <li>PSC machine provides high core count CPUs and GPUs for testing</li>
                <li>CPU: AMD EPYC 7742 64-Core Processor (can access multiple nodes for more cores)</li>
                <li>GPU: NVIDIA TESLA V100 - 5120 CUDA cores, Memory Bandwidth: Up to 900 GB/s</li>
            </ul>
        </li>
        <li>
            <strong>GHC Machine for CPU & GPU Testing</strong>
            <ul class="sub-list">
                <li>GHC machine provides lower core count CPUs and GPUs but is ideal for testing since PSC machine has limitations on balance</li>
                <li>CPU: Intel(R) Core(TM) i7-9700 8-Core Processor</li>
                <li>GPU: NVIDIA RTX2080 - 2944 CUDA cores, Memory Bandwidth: 448 GB/s</li>
            </ul>
        </li>
    </ul>

    <h2>SCHEDULE</h2>
    <table border="1">
        <thead>
            <tr>
                <th>Dates</th>
                <th>Task</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>11/11-11/17</td>
                <td>
                    <ul>
                        <li>Collect height and color maps</li>
                        <li>Survey and decide C++ rendering packages</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td>11/18-11/24</td>
                <td>
                    <ul>
                        <li>Finish the serial version of Perspective Projection</li>
                        <li>Prepare test cases for parallelism</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td>11/25-12/1</td>
                <td>
                    <ul>
                        <li>Convert the sequential version into the parallel one</li>
                        <li>Test and analyze parallel version performance</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td>12/2-12/8</td>
                <td>
                    <ul>
                        <li>Visualize rendering results for demo</li>
                        <li>Implement advance ray-tracing (if available)</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td>12/9-12/15</td>
                <td>
                    <ul>
                        <li>Write the report and poster</li>
                    </ul>
                </td>
            </tr>
        </tbody>
    </table>
    </table>

    <hr>
    <h1>Milestone Overview</h1>
    <h2>Schedule</h2>
    <table>
        <tr>
            <th>Time Period</th>
            <th>Tasks</th>
        </tr>
        <tr>
            <td>11/11-11/17</td>
            <td>
                <ul>
                    <li>Collect height and color maps: Connie, Ching Han</li>
                    <li>Survey and decide C++ rendering packages: Connie, Ching Han</li>
                </ul>
            </td>
        </tr>
        <tr>
            <td>11/18-11/24</td>
            <td>
                <ul>
                    <li>Finish the serial version of Perspective Projection: Ching Han</li>
                    <li>Prepare test cases for parallelism: Connie</li>
                </ul>
            </td>
        </tr>
        <tr>
            <td>11/25-12/1</td>
            <td>
                <ul>
                    <li>Convert the sequential version into the parallel one:
                        <ul>
                            <li>CPU parallel: Connie</li>
                            <li>GPU parallel:
                                <ul>
                                    <li>gpu_launchKernalEveryDz: Ching Han</li>
                                    <li>gpu_launchKernalOnce: Connie</li>
                                    <li>gpu_parallelDz: Ching Han</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li>Test and analyze parallel version performance: Connie, Ching Han</li>
                </ul>
            </td>
        </tr>
        <tr>
            <td>12/2-12/8</td>
            <td>
                <ul>
                    <li>Work on optimizing the serial portion of the code: Ching Han, Connie</li>
                    <li>Test and analyze parallel version performance: Ching Han</li>
                    <li>Visualize rendering results for demo: Connie</li>
                    <li>Implement advanced ray-tracing (if available): Ching Han, Connie</li>
                </ul>
            </td>
        </tr>
        <tr>
            <td>12/9-12/15</td>
            <td>
                <ul>
                    <li>Write the report and poster: Ching Han, Connie</li>
                </ul>
            </td>
        </tr>
    </table>

    <h2><strong>Progress Update</strong></h2>
    <p>CPU and GPU parallel codes have been implemented and tested on GHC machine. There are currently one sequential CPU code for baseline and four versions of parallel CPU/GPU codes with different scheduling strategies.</p>

    <h3>CPU Parallel</h3>
    <p>The CPU code employed OpenMP to parallelize the screen rendering process. Within each depth layer, OpenMP is utilized to parallelize the vertical rendering of the images. This entails rendering vertical lines of an image in parallel. The parallelism of this method is limited to the width of the image since there exist dependencies between vertical pixels.</p>

    <h3>GPU Parallel</h3>
    <p>The GPU codes employed CUDA for terrain rendering.</p>
    <ul>
        <li><strong>gpu_launchKernalEveryDz:</strong>
            <p>This code represents the initial implementation of GPU code. The parallelization mechanism is identical to that of the CPU portion. Within each depth layer, a GPU kernel is launched, enabling parallel rendering of each vertical line. While this method offers superior performance compared to the CPU implementation, it is limited by the number of kernel launches, which leads to substantial overhead as the number of depth layers increases. The implementation is also limited by the width of the output image as only “width” vertical lines can be processed concurrently. This significantly underutilized the GPU.</p>
        </li>
        <li><strong>gpu_launchKernalOnce:</strong>
            <p>This code represents an enhanced version of the <code>gpu_launchKernalEveryDz</code> function. Unlike the previous function, it launches a kernel for all depth layers instead of individual layers. However, the code is still constrained to the “width” number of threads.</p>
        </li>
        <li><strong>gpu_parallelDz:</strong>
            <p>This code aims to address the limitation of previous codes, which are restricted to launching only a specified number of threads. The code is structured into two distinct sections: the first section handles the conversion of 3D depth to 2D coordinates, while the second section is responsible for rendering the image.</p>
            <ul>
                <li>The initial kernel optimizes the utilization of CUDA cores by concurrently calculating and transforming 3D coordinates to 2D coordinates. Subsequently, it retrieves the color and height data from the color map and height map and stores them in the VRAM. This kernel launches multiple thread blocks, each comprising 2D thread blocks that span over two depth layers and a width of 256 pixels. Consequently, each thread block contains a total of 512 threads.</li>
                <li>The second kernel is responsible for rendering the image. Due to the dependencies, only vertical lines on the image can be processed concurrently. Consequently, only “width” number of threads can be launched. Within each thread, it iterates through all depth layers and retrieves the color and height data computed from the preceding kernel. Subsequently, it writes colors appropriately to each pixel within a vertical line.</li>
            </ul>
        </li>
    </ul>

    <h2>Goals</h2>
    <p>We believe that we can achieve our goal performance. Our goal is to render 60 frames of terrain in a second such that we can achieve at least 60FPS to simulate real gaming situations. We are currently able to parallelize the computation of the transformation of 3D view to 2D images, which includes the height and color information, and gain reasonable speedup. Regarding difficulty, we are currently working on developing an algorithm to better parallelize the screen rendering mechanism, which consists of many dependencies. The screen rendering process prioritizes rendering the heights of closer objects first, displaying them on the screen, and then progressively rendering the subsequent layers of objects that are further away. This sequential progress will be the bottleneck of the performance. Therefore, our goal is to optimize/rewrite this portion of the code to leverage as much parallelism as possible. </p>
    <p><strong>Nice-To-Have</strong></p>
    <ul>
        <li><strong>Advanced Rendering Features:</strong>  The goal is to enhance the visual realism and efficiency of terrain rendering by implementing different rendering algorithms tailored to specific needs. These advanced features aim to achieve higher FPS than current GPU parallel methods  at high resolutions, ensuring smooth performance even in dynamic gaming environments. Combined, these techniques provide a robust foundation for tackling the challenges of rendering detailed voxel terrains while maintaining high performance.</li>
        <li><strong>Comprehensive Visualizations:</strong> These visualizations are designed to bridge the gap between technical details and user experience, emphasizing the practical impact of the rendering optimizations. Users can observe how the rendering pipeline adapts in real time, maintaining performance across various configurations. This requires setting up a server capable of managing rendering computations or precomputed data while providing a responsive front-end interface for visualization.</li>
    </ul>
    <h2>Plan on Poster Session</h2>
    <h3><strong>Performance Graphs</strong></h3>
    <p>We will include performance metrics for a detailed comparison:</p>
    <ul>
        <li><strong>Speedup Graphs:</strong>
            <ul>
                <li>Show the speedup achieved by each implementation compared to the baseline (serial CPU).</li>
                <li>Highlight the scalability of <code>gpu_parallelDz</code> with different GPU methods as the depth and image resolution increase.</li>
            </ul>
        </li>
        <li><strong>Resource Utilization:</strong>
            <ul>
                <li>Analyze and visually present how much time is spent on each of the two main computational stages, 3D-to-2D conversion and image rendering, of all implementations.</li>
                <li>Include bar charts illustrating GPU resource utilization for each implementation.</li>
            </ul>
        </li>
    </ul>

    <h3><strong>Key Lessons and Insights</strong></h3>
    <p>We will present key observations and insights in the form of concise bullet points and visualizations:</p>
    <ul>
        <li>Explain how vertical line dependencies impact parallelism and how we mitigated this in <code>gpu_parallelDz</code>.</li>
        <li>Highlight how optimizing thread block configurations and reducing kernel launch overhead dramatically improves performance.</li>
    </ul>

    <h3><strong>Interactive Demo (Nice-To-Have)</strong></h3>
    <p>We will showcase a real-time rendering demo that highlights the performance differences between the various implementations on both the CPU and GPU. The demo will include:</p>
    <ul>
        <li><strong>CPU vs GPU videos:</strong> Demonstrate rendering speeds for the same terrain data across different methods (CPU parallelized with OpenMP and GPU parallelized using CUDA).</li>
        <li><strong>GPU optimization levels videos:</strong>
            <ul>
                <li>Compare the performance of <code>gpu_launchKernalEveryDz</code>, <code>gpu_launchKernalOnce</code>, and <code>gpu_parallelDz</code> visually and in terms of rendering speed.</li>
                <li>Highlight how increasing GPU utilization improves the terrain rendering process.</li>
            </ul>
        </li>
        <li><strong>Dynamic Terrain Interaction:</strong> Users can modify terrain parameters (e.g., depth, resolution) and observe how the different methods handle these changes in real time.</li>
    </ul>
    <h2>Preliminary Results</h2>
    <table>
        <tr>
            <th></th>
            <th>Serial CPU</th>
            <th>Parallel CPU</th>
            <th>gpu_launchKernalEveryDz</th>
            <th>gpu_launchKernalOnce</th>
            <th>gpu_parallelDz</th>
        </tr>
        <tr>
            <td>Speedup</td>
            <td>1</td>
            <td>1.97</td>
            <td>2.55</td>
            <td>6.58</td>
            <td>9.98</td>
        </tr>
    </table>

    <h2>Concerns</h2>
    <p>To enhance the performance of the sequential code segment responsible for rendering colors in the output images, an algorithm for partial parallelization is essential. This sequential code calculates the height of objects from the front to the back of each depth layer. Since the occluded parts of the image are not visible in the output images, a sequential mechanism determines the heights of objects from the front to the back of each depth layer. This process must be performed sequentially, as the heights of closer objects must be accessed before determining the region to render for subsequent layers. For instance, if a high mountain is in the foreground depth, the tree behind it in the background depth does not need to be rendered because it is obscured by the mountain.</br>
    The current performance is impeded by this mechanism, which necessitates sequential execution. Several proposals have been put forth, including dividing the image into multiple blocks to be rendered concurrently and then sequentially merging the blocks. However, the implementation details and computational efficiency must be thoroughly analyzed before proceeding. Our primary focus is on identifying potential ways to parallelize this portion of the code.</p>

</body>
</html>